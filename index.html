<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BarnPilot Course Designer ‚Äî Rule Sets (Show Jumping / Eventing)</title>
<style>
  :root{--ink:#111;--muted:#666;--line:#333;--bg:#f6f6f6;--card:#fff;--bd:#ddd;--hl:#0b84ff}
  *{box-sizing:border-box}
  body{margin:16px;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--ink)}
  h1{margin:0 0 12px;font-size:20px}
  .layout{display:grid;grid-template-columns:420px 1fr 380px;gap:14px;align-items:start}
  .card{background:var(--card);border:1px solid var(--bd);border-radius:10px;padding:12px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:4px}
  input,select,button{width:100%;padding:9px;border:1px solid #cfcfcf;border-radius:8px;font-size:14px;background:#fff;color:var(--ink)}
  input[type="range"]{padding:0}
  button.primary{background:var(--ink);color:#fff;border-color:var(--ink)}
  button.ghost{background:#fff;color:#111}
  .stack{display:flex;gap:8px;flex-wrap:wrap}
  .sep{height:1px;background:#eee;margin:10px 0}
  canvas{width:100%;height:auto;background:#fff;border:1px solid var(--bd);border-radius:10px}
  .small{font-size:12px;color:#555}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  pre{white-space:pre-wrap}
  #status{font-size:12px;color:#444}
  .list{display:flex;flex-direction:column;gap:8px;max-height:640px;overflow:auto}
  .item{border:1px solid var(--bd);border-radius:10px;padding:10px;background:#fff}
  .item.active{outline:2px solid var(--hl);outline-offset:0}
  .item .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .badge{font-size:12px;background:#efefef;border:1px solid #ddd;border-radius:999px;padding:2px 8px;margin-right:6px}
  .muted{color:#888;font-size:12px}
  .thumb{width:100%;height:120px;border:1px solid var(--bd);border-radius:10px;background:#fff}
  .toggle-row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
</style>
</head>
<body>
<h1>üèá BarnPilot Course Designer ‚Äî Rule Sets (Show Jumping / Eventing)</h1>

<div class="layout">
  <!-- Global Controls -->
  <div class="card">
    <div class="row">
      <div><label>Rule Set</label>
        <select id="ruleSet">
          <option value="jumping" selected>Show Jumping (FEI/USEF style)</option>
          <option value="eventing">Eventing (USEA Appendix 1 style)</option>
        </select>
      </div>
      <div><label>Level Preset</label>
        <select id="level">
          <option value="young">Lower / Intro‚Äì1.0 m</option>
          <option value="childAdult" selected>Mid / 1.10‚Äì1.20 m</option>
          <option value="open">Upper / 1.30 m+</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div><label>Course Template</label>
        <select id="template">
          <option value="hunter">Hunter (flowing)</option>
          <option value="tableII" selected>Table II‚Äëstyle</option>
          <option value="tableIII">Table III (speed)</option>
          <option value="gp">Grand Prix (technical)</option>
        </select>
      </div>
      <div><label># Obstacles (6‚Äì16)</label><input id="jumpCount" type="number" value="10" min="6" max="16"></div>
    </div>

    <div class="row">
      <div><label>Arena Width</label><input id="arenaW" type="number" value="240" min="120" step="5"></div>
      <div><label>Arena Height</label><input id="arenaH" type="number" value="180" min="120" step="5"></div>
    </div>

    <div class="row">
      <div><label>Units</label>
        <select id="units">
          <option value="ft" selected>Feet</option>
          <option value="m">Meters</option>
        </select>
      </div>
      <div><label>Oxer Target</label>
        <select id="oxers">
          <option value="0.4">40%</option>
          <option value="0.5" selected>50%</option>
          <option value="0.6">60%</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Course Coverage <span id="covLbl">85%</span></label>
        <input id="coverage" type="range" min="60" max="100" value="85">
      </div>
      <div>
        <label>Variety <span id="varLbl">60%</span></label>
        <input id="variety" type="range" min="0" max="100" value="60">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Stride Range (min‚Äìmax)</label>
        <div class="row" style="grid-template-columns:1fr 1fr;gap:6px;margin:0">
          <input id="minStride" type="number" value="4" min="3" max="8" step="1">
          <input id="maxStride" type="number" value="7" min="4" max="9" step="1">
        </div>
      </div>
      <div>
        <label>Combo Distances (ft)</label>
        <div class="row" style="grid-template-columns:1fr 1fr;gap:6px;margin:0">
          <input id="combo1" type="number" value="24" min="20" max="30" step="0.5" title="1‚Äëstride">
          <input id="combo2" type="number" value="36" min="32" max="42" step="0.5" title="2‚Äëstride">
        </div>
      </div>
    </div>

    <div class="row">
      <div><label>Combination Placement</label>
        <select id="combo">
          <option value="auto" selected>Auto (follows rule set)</option>
          <option value="none">None</option>
        </select>
      </div>
      <div class="toggle-row" style="margin-top:22px">
        <label><input id="keepLocked" type="checkbox" checked style="width:auto"> Keep locked on Generate</label>
        <label><input id="showLabels" type="checkbox" checked style="width:auto"> Show stride labels</label>
        <label><input id="gridOn" type="checkbox" style="width:auto"> Show grid</label>
        <label><input id="snapOn" type="checkbox" checked style="width:auto"> Snap</label>
      </div>
    </div>

    <div class="stack">
      <button id="btnGenerate" class="primary">Generate Course</button>
      <button id="btnExportPNG" class="ghost">Export PNG</button>
      <button id="btnExportPDF" class="ghost">Export PDF (Print)</button>
      <button id="btnReset" class="ghost">Reset</button>
    </div>

    <div class="sep"></div>
    <div class="small">
      ‚Ä¢ Choose **Rule Set** first (Show Jumping vs Eventing).<br>
      ‚Ä¢ Click a fence to move; Shift+Click to lock/unlock; editor updates live.<br>
      ‚Ä¢ Combo distance fields control **1‚Äëstride/2‚Äëstride** in‚Äëand‚Äëout gaps.
    </div>
  </div>

  <!-- Canvas -->
  <div class="card">
    <canvas id="cv" width="1280" height="900"></canvas>
    <div id="status" class="small" style="margin-top:8px;"></div>
    <div class="sep"></div>
    <div class="small"><b>Text Plan</b> (copy/paste):</div>
    <pre id="plan" class="mono"></pre>
  </div>

  <!-- Preview & Editor -->
  <div class="card">
    <div class="small" style="margin-bottom:6px"><b>Live Jump Preview</b></div>
    <canvas id="thumb" class="thumb" width="360" height="120"></canvas>

    <div class="sep"></div>
    <div class="muted" style="margin-bottom:6px">Tap a card to select; edit fields update the preview instantly.</div>
    <div id="list" class="list"></div>

    <div class="sep"></div>
    <div class="stack">
      <button id="btnAddJump">+ Add Jump</button>
      <button id="btnInsertCombo" title="Insert a combination (1- or 2-stride) after selected">+ Combo After Selected</button>
      <button id="btnDeleteJump">Delete Selected</button>
      <button id="btnMoveUp">Move Up</button>
      <button id="btnMoveDown">Move Down</button>
    </div>
  </div>
</div>

<script>
/* ===== Canvas & UI refs ===== */
const CV = document.getElementById('cv'), ctx = CV.getContext('2d');
const TH = document.getElementById('thumb'), tctx = TH.getContext('2d');
const planEl = document.getElementById('plan'), statusEl = document.getElementById('status'), listEl = document.getElementById('list');
const covSlider = document.getElementById('coverage'), covLbl = document.getElementById('covLbl');
const varSlider = document.getElementById('variety'), varLbl = document.getElementById('varLbl');

/* ===== Constants ===== */
const FT_PER_M=3.28084, STRIDE=12, APPR=6, MIN_APPROACH_STRIDES=3;
const DOT=[12,10], LINE_WIDTH=2, ARROW_THICK=2;
const TYPES=['Vertical','Oxer','Triple Bar'];
const HEIGHT_BANDS={ Vertical:[2.6,3.2,3.6], Oxer:[3.0,3.5,3.9], 'Triple Bar':[3.0,3.6,4.0] };
const TEMPLATE={ hunter:{turnBias:0.08}, tableII:{turnBias:0.18}, tableIII:{turnBias:0.28}, gp:{turnBias:0.34} };
const LEVEL={ young:{speed:340, combo:{one:true,two:true}}, childAdult:{speed:360, combo:{one:true,two:true}}, open:{speed:375, combo:{one:true,two:true}} };

const rnd=(a,b)=>a+Math.random()*(b-a), clamp=(v,a,b)=>Math.max(a,Math.min(b,v)), pick=a=>a[Math.floor(Math.random()*a.length)];
const ft=(v,u)=>u==='m'?v*FT_PER_M:v, un=(v,u)=>u==='m'?v/FT_PER_M:v;
function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }}

/* ===== Rule Sets (merged) ===== */
const RULES={
  jumping:{
    label:'Show Jumping',
    // per level (maps to our 3 presets)
    perLevel:{
      young:{ minLineFt:82, allowDouble:true, allowTriple:false, firstComboIndexMin:4, oxerBOrCAfterMinTwoStrideFt:35, airyEarly:false },
      childAdult:{ minLineFt:70, allowDouble:true, allowTriple:true, firstComboIndexMin:4, oxerBOrCAfterMinTwoStrideFt:35, airyEarly:false },
      open:{ minLineFt:70, allowDouble:true, allowTriple:true, firstComboIndexMin:3, oxerBOrCAfterMinTwoStrideFt:35, airyEarly:true }
    },
    lastFenceTowardIngateUpperOnly:true
  },
  eventing:{
    label:'Eventing',
    perLevel:{
      young:{ // Beginner/Novice blended
        minLineFt:82, allowDouble:true, allowTriple:false, firstComboIndexMin:5, oxerBOrCAfterMinTwoStrideFt:34.5, airyEarly:false
      },
      childAdult:{ // Training/Modified
        minLineFt:70, allowDouble:true, allowTriple:true, firstComboIndexMin:5, oxerBOrCAfterMinTwoStrideFt:35, airyEarly:false
      },
      open:{ // Preliminary+
        minLineFt:70, allowDouble:true, allowTriple:true, firstComboIndexMin:4, oxerBOrCAfterMinTwoStrideFt:35, airyEarly:true
      }
    },
    lastFenceTowardIngateUpperOnly:true
  }
};

/* ===== State ===== */
let S={ units:'ft', Wft:240, Hft:180, jumps:[], lines:[], curves:[], arrows:[], origin:{x:0,y:0}, scale:1, start:{x:0,y:0}, finish:{x:0,y:0}, selected:-1 };

/* ===== UI ===== */
function readUI(){
  const units=document.getElementById('units').value;
  const W=ft(parseFloat(document.getElementById('arenaW').value||240), units);
  const H=ft(parseFloat(document.getElementById('arenaH').value||180), units);
  const N=clamp(parseInt(document.getElementById('jumpCount').value||10,10),6,16);
  const lvlKey=document.getElementById('level').value, tmplKey=document.getElementById('template').value;
  const oxerPct=parseFloat(document.getElementById('oxers').value), comboOpt=document.getElementById('combo').value;
  const keepLocked=document.getElementById('keepLocked').checked;
  const showLabels=document.getElementById('showLabels').checked;
  const gridOn=document.getElementById('gridOn').checked;
  const snapOn=document.getElementById('snapOn').checked;
  const coverage=parseInt(document.getElementById('coverage').value,10)/100;
  const variety=parseInt(document.getElementById('variety').value,10)/100;
  const minStride=parseInt(document.getElementById('minStride').value,10);
  const maxStride=parseInt(document.getElementById('maxStride').value,10);
  const combo1=parseFloat(document.getElementById('combo1').value||24);
  const combo2=parseFloat(document.getElementById('combo2').value||36);
  const ruleSet=document.getElementById('ruleSet').value;
  return {units,W,H,N,lvlKey,tmplKey,oxerPct,comboOpt,keepLocked,showLabels,gridOn,snapOn,coverage,variety,minStride,maxStride,combo1,combo2,ruleSet};
}
covSlider.addEventListener('input',()=>{ covLbl.textContent = covSlider.value+'%'; });
varSlider.addEventListener('input',()=>{ varLbl.textContent = varSlider.value+'%'; });

/* ===== Distance logic ===== */
function relatedFt(strides, fromType, toType){
  let base=strides*STRIDE + APPR;
  const spread=t=>t==='Oxer'||t==='Triple Bar';
  if(spread(fromType) && toType==='Vertical') base+=2;
  if(fromType==='Vertical' && spread(toType)) base-=2;
  return base;
}
function comboGapFt(parts){ const U=readUI(); return parts===1?U.combo1:U.combo2; }

/* ===== Variety helpers ===== */
function poissonSample(points, w, h, radius, tries=40){
  for(let t=0;t<tries;t++){
    const p={x:rnd(radius,w-radius), y:rnd(radius,h-radius)};
    if(points.every(q=>Math.hypot(q.x-p.x,q.y-p.y)>=radius)) return p;
  }
  return null;
}
function relax(points, w, h, radius, iters=20){
  for(let k=0;k<iters;k++){
    for(let i=0;i<points.length;i++){
      for(let j=i+1;j<points.length;j++){
        const a=points[i], b=points[j];
        const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy);
        if(d<radius && d>0){
          const push=(radius-d)/2, ux=dx/d, uy=dy/d;
          a.x=clamp(a.x-ux*push,0,w); a.y=clamp(a.y-uy*push,0,h);
          b.x=clamp(b.x+ux*push,0,w); b.y=clamp(b.y+uy*push,0,h);
        }
      }
    }
  }
}

/* ===== Angle & scoring ===== */
function angleDeg(a,b,c){
  const v1={x:a.x-b.x,y:a.y-b.y}, v2={x:c.x-b.x,y:c.y-b.y};
  const d1=Math.hypot(v1.x,v1.y)||1, d2=Math.hypot(v2.x,v2.y)||1;
  const cos=(v1.x*v2.x+v1.y*v2.y)/(d1*d2);
  return Math.acos(clamp(cos,-1,1))*180/Math.PI;
}
function scoreTrack(list, W, H, cfg){
  let score=1000, penalties=0;
  const buf=cfg.edgeBuf, minSeg=cfg.minSeg, minAng=cfg.minAng, maxAng=cfg.maxAng;
  for(let i=0;i<list.length;i++){
    const p=list[i];
    if(!(p.x>buf && p.x<W-buf && p.y>buf && p.y<H-buf)){ score-=30; penalties++; }
    if(i>0){
      const d=Math.hypot(p.x-list[i-1].x, p.y-list[i-1].y);
      if(d<minSeg){ score -= (minSeg-d)*2; penalties++; }
    }
    if(i>=2){
      const ang=angleDeg(list[i-2], list[i-1], list[i]);
      if(ang<minAng){ score -= (minAng-ang)*1.5; penalties++; }
      if(ang>maxAng){ score -= (ang-maxAng)*1.5; penalties++; }
    }
  }
  if(list.length>=3){
    const a=list.at(-3), b=list.at(-2), c=list.at(-1);
    const d1=Math.hypot(b.x-a.x,b.y-a.y), d2=Math.hypot(c.x-b.x,c.y-b.y);
    if(d1<cfg.finalMin){ score -= (cfg.finalMin-d1)*2; penalties++; }
    if(d2<cfg.finalMin){ score -= (cfg.finalMin-d2)*2; penalties++; }
  }
  return {score, penalties};
}

/* ===== Generator ===== */
function generate(){
  const U=readUI(), lvl=LEVEL[U.lvlKey], RS=RULES[U.ruleSet].perLevel[U.lvlKey], pad=50;
  S.units=U.units; S.Wft=U.W; S.Hft=U.H;
  S.scale=Math.min((CV.width-2*pad)/U.W,(CV.height-2*pad)/U.H);
  S.origin={x:(CV.width-U.W*S.scale)/2, y:(CV.height-U.H*S.scale)/2};

  const keep=(U.keepLocked? S.jumps.filter(j=>j.locked): []).map(j=>({...j}));
  const minBuf=MIN_APPROACH_STRIDES*STRIDE;
  const covPadX=(S.Wft*(1-U.coverage))/2, covPadY=(S.Hft*(1-U.coverage))/2;
  const usable={x0:covPadX,y0:covPadY,x1:S.Wft-covPadX,y1:S.Hft-covPadY,w:S.Wft-2*covPadX,h:S.Hft-2*covPadY};

  let best=null, bestScore=-Infinity;
  const maxAttempts=120;

  for(let att=0; att<maxAttempts; att++){
    const relaxPct=att/(maxAttempts-1);
    // Edge & angle constraints (we soften over attempts)
    const cfg={
      edgeBuf: minBuf * (1 - 0.5*relaxPct),
      minSeg:  Math.max(RS.minLineFt, (4.5*STRIDE)*(1 - 0.2*relaxPct)),
      minAng:  40 - 10*relaxPct,
      maxAng:  160 + 10*relaxPct,
      finalMin: Math.max(RS.minLineFt*0.8, (4.5*STRIDE)*(1 - 0.2*relaxPct))
    };

    // Seed / types
    let jumps=[];
    keep.forEach(j=>{
      jumps.push({
        x:clamp(j.x, usable.x0+cfg.edgeBuf, usable.x1-cfg.edgeBuf),
        y:clamp(j.y, usable.y0+cfg.edgeBuf, usable.y1-cfg.edgeBuf),
        type:j.type, heightFt:j.heightFt, locked:true, angle:0, isComboPart:false
      });
    });

    const need=U.N-jumps.length;
    const wantOxer=Math.round(U.N*U.oxerPct);
    let haveOxer=jumps.filter(j=>j.type==='Oxer').length, putOxer=Math.max(0,wantOxer-haveOxer);

    // anchors serpentine
    const cols=Math.ceil(U.N/2)+1; let anchors=[];
    const flip=Math.random()<0.5;
    for(let i=0;i<cols;i++){
      const x=usable.x0 + i*((usable.x1-usable.x0)/Math.max(1,(cols-1)));
      const y = ((i%2===0) ^ flip) ? (usable.y0+cfg.edgeBuf) : (usable.y1-cfg.edgeBuf);
      anchors.push({x,y});
    }
    if(U.variety>0.15) shuffle(anchors);

    // Poisson radius influenced by rule min line
    const baseRadius = Math.max(26, RS.minLineFt*0.25) + U.variety*12;

    for(let i=0;i<need;i++){
      let p=poissonSample(jumps, S.Wft, S.Hft, baseRadius);
      if(!p){
        const a=anchors[Math.min(i,anchors.length-1)] || {x:rnd(usable.x0,usable.x1), y:rnd(usable.y0,usable.y1)};
        p={x: clamp(a.x+rnd(-18,18), usable.x0+cfg.edgeBuf, usable.x1-cfg.edgeBuf),
           y: clamp(a.y+rnd(-18,18), usable.y0+cfg.edgeBuf, usable.y1-cfg.edgeBuf)};
      }
      // choose type (respect balance)
      let type='Vertical';
      if(putOxer>0){ type='Oxer'; putOxer--; }
      else if(Math.random()<0.25 + 0.25*U.variety){ type='Triple Bar'; }
      const band=HEIGHT_BANDS[type], idx=(U.lvlKey==='young'?0:(U.lvlKey==='childAdult'?1:2));
      jumps.push({x:p.x,y:p.y,type,heightFt:band[idx],label:'',locked:false,angle:0,isComboPart:false});
    }

    relax(jumps, S.Wft, S.Hft, baseRadius, Math.round(10+relaxPct*8));

    // Order from start with bias flips
    const start={x:minBuf,y:minBuf}; let remain=jumps.slice(), ordered=[], cur=start, bias=Math.random()<0.5?-1:1;
    while(remain.length){
      remain.sort((a,b)=>{
        const da=Math.hypot(a.x-cur.x,a.y-cur.y), db=Math.hypot(b.x-cur.x,b.y-cur.y);
        const biasA=bias*(a.x-cur.x), biasB=bias*(b.x-cur.x);
        return (da - 0.06*U.variety*biasA) - (db - 0.06*U.variety*biasB);
      });
      const nx=remain.shift(); ordered.push(nx); cur=nx; bias*=(Math.random()<0.6?-1:1);
    }

    // ‚Äî‚Äî‚Äî Rule‚Äëaware combination placement ‚Äî‚Äî‚Äî
    if(U.comboOpt!=='none' && RS.allowDouble){
      const firstIdx = RS.firstComboIndexMin;
      const canTriple = RS.allowTriple && ordered.length >= firstIdx+3 && Math.random()<0.35;
      if(canTriple){
        // build triple: base, +1 stride, +2 stride (respect oxer-at-b/c rule with 2‚Äëstride >= rule)
        const baseIdx = Math.max(firstIdx, Math.floor(ordered.length*0.45));
        const base=ordered[baseIdx];
        const gap1=comboGapFt(1), gap2=comboGapFt(1); // keep triples with 1s for fairness
        const dir=(base.x<S.Wft/2)?1:-1;
        const pB={x:clamp(base.x+dir*gap1, usable.x0+cfg.edgeBuf, usable.x1-cfg.edgeBuf), y:base.y};
        const pC={x:clamp(pB.x+dir*gap2, usable.x0+cfg.edgeBuf, usable.x1-cfg.edgeBuf), y:base.y};
        ordered.splice(baseIdx+1,0,{...pB,type:'Vertical',heightFt:base.heightFt,locked:false,angle:0,isComboPart:true});
        ordered.splice(baseIdx+2,0,{...pC,type:'Oxer',heightFt:base.heightFt,locked:false,angle:0,isComboPart:true});
      }else{
        // a single double with 1 or 2 strides; ensure if oxer is b, two‚Äëstride meets min
        const baseIdx = Math.max(firstIdx, Math.floor(ordered.length*0.45));
        const base=ordered[baseIdx];
        const twoStride = Math.random()<0.5;
        const gap = comboGapFt(twoStride?2:1);
        const dir=(base.x<S.Wft/2)?1:-1;
        const nx=clamp(base.x+dir*gap, usable.x0+cfg.edgeBuf, usable.x1-cfg.edgeBuf);
        const ny=base.y;
        let typeB = (twoStride && gap < RS.oxerBOrCAfterMinTwoStrideFt) ? 'Vertical' : (Math.random()<0.5?'Vertical':'Oxer');
        if(twoStride && typeB==='Oxer' && gap<RS.oxerBOrCAfterMinTwoStrideFt){ typeB='Vertical'; }
        ordered.splice(baseIdx+1,0,{x:nx,y:ny,type:typeB,heightFt:base.heightFt,locked:false,angle:0,isComboPart:true});
      }
    }

    // Angles for drawing
    for(let i=0;i<ordered.length;i++){
      const prev=(i===0)? start : ordered[i-1];
      ordered[i].angle=Math.atan2(ordered[i].y-prev.y, ordered[i].x-prev.x);
    }

    // Score & keep best
    const {score,penalties}=scoreTrack(ordered,S.Wft,S.Hft,{
      edgeBuf:cfg.edgeBuf,
      minSeg:RS.minLineFt,
      minAng:40, maxAng:170, finalMin:RS.minLineFt*0.85
    });
    if(score>bestScore){ bestScore=score; best=ordered; }
    if(penalties<=1 && score>900) break;
  }

  // Guaranteed fallback (zig‚Äëzag)
  if(!best || !best.length){
    best=[];
    const U2=readUI(); const N=U2.N;
    const left=minBuf, right=S.Wft-minBuf, top=minBuf, bottom=S.Hft-minBuf;
    for(let i=0;i<N;i++){
      const x = (i%2===0)? left : right;
      const y = top + (i/(N-1))*(bottom-top);
      const type = (i%3===0)? 'Oxer' : 'Vertical';
      const band=HEIGHT_BANDS[type], idx=(U2.lvlKey==='young'?0:(U2.lvlKey==='childAdult'?1:2));
      best.push({x,y,type,heightFt:band[idx],label:'',locked:false,angle:0,isComboPart:false});
    }
  }

  // Apply state
  S.jumps=best;
  S.start={x:MIN_APPROACH_STRIDES*STRIDE, y:MIN_APPROACH_STRIDES*STRIDE};
  S.finish={x:S.Wft-MIN_APPROACH_STRIDES*STRIDE, y:S.Hft-MIN_APPROACH_STRIDES*STRIDE};
  S.jumps.forEach((j,i)=> j.label=`Jump ${i+1}`);
  S.jumps.forEach((j,i)=>{ const p=(i===0)?S.start:S.jumps[i-1]; j.angle=Math.atan2(j.y-p.y, j.x-p.x); });

  computeCurves(); draw(); emitPlanAndStatus(); renderList(); drawThumb();
}

/* ===== Curves & arrows ===== */
function computeCurves(){
  const U=readUI(), tmpl=TEMPLATE[U.tmplKey];
  S.lines=[]; S.curves=[]; S.arrows=[];
  const minS=Math.min(U.minStride,U.maxStride), maxS=Math.max(U.minStride,U.maxStride);

  for(let i=1;i<S.jumps.length;i++){
    const a=S.jumps[i-1], b=S.jumps[i];
    const dx=b.x-a.x, dy=b.y-a.y, d=Math.hypot(dx,dy)||1;
    let best={s:minS,err:Infinity};
    for(let s=minS;s<=maxS;s++){
      const t=relatedFt(s,a.type,b.type), e=Math.abs(d-t);
      if(e<best.err) best={s,err:e};
    }
    S.lines.push({i0:i-1,i1:i,strides:best.s});
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2, nx=-dy/d, ny=dx/d;
    const curvature=0.18*d*(tmpl.turnBias+0.6);
    const cx=mx+nx*curvature, cy=my+ny*curvature;
    S.curves.push({a:{x:a.x,y:a.y}, c:{x:cx,y:cy}, b:{x:b.x,y:b.y}, strides:best.s});
    S.arrows.push({a:{x:a.x,y:a.y}, c:{x:cx,y:cy}, b:{x:b.x,y:b.y}});
  }
}

/* ===== Snap ===== */
function snapPosition(i, x, y){
  const U=readUI(); if(!U.snapOn) return {x,y};
  const minS=Math.min(U.minStride,U.maxStride), maxS=Math.max(U.minStride,U.maxStride);
  const prev=(i>0)?S.jumps[i-1]:null, next=(i<S.jumps.length-1)?S.jumps[i+1]:null;
  const candidates=[];
  function snapFrom(Ax,Ay,Px,Py,tFrom,tTo){
    const vx=Px-Ax, vy=Py-Ay, d=Math.hypot(vx,vy)||1, ux=vx/d, uy=vy/d; let best=null;
    for(let s=minS;s<=maxS;s++){
      const target=relatedFt(s,tFrom,tTo), cx=Ax+ux*target, cy=Ay+uy*target, err=Math.hypot(cx-Px,cy-Py);
      if(!best||err<best.err) best={x:cx,y:cy,err};
    } return best;
  }
  if(prev) candidates.push(snapFrom(prev.x,prev.y,x,y,prev.type,S.jumps[i].type));
  if(next) candidates.push(snapFrom(next.x,next.y,x,y,S.jumps[i].type,next.type));
  if(!candidates.length) return {x,y};
  candidates.sort((a,b)=>a.err-b.err); return {x:candidates[0].x,y:candidates[0].y};
}

/* ===== Drawing ===== */
function worldToPx(pt){ return {x:S.origin.x+pt.x*S.scale, y:S.origin.y+pt.y*S.scale}; }
function drawGrid(){ const {gridOn}=readUI(); if(!gridOn) return; const step=30; ctx.save(); ctx.strokeStyle='#eee'; ctx.lineWidth=1;
  for(let x=0;x<=S.Wft;x+=step){ const p1=worldToPx({x,y:0}), p2=worldToPx({x,y:S.Hft}); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();}
  for(let y=0;y<=S.Hft;y+=step){ const p1=worldToPx({x:0,y}), p2=worldToPx({x:S.Wft,y}); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();}
  ctx.restore();
}
function drawArena(){ const x=S.origin.x, y=S.origin.y, w=S.Wft*S.scale, h=S.Hft*S.scale; ctx.lineWidth=1.5; ctx.strokeStyle='#aaa'; ctx.strokeRect(x,y,w,h);
  ctx.fillStyle='#666'; ctx.font='12px Arial'; const u=S.units==='m'?'m':'ft'; ctx.fillText(`Arena ${Math.round(un(S.Wft,S.units))} x ${Math.round(un(S.Hft,S.units))} ${u}`, x+8,y+16);
}
function drawRectLabel(x,y,text){ const pad=3; ctx.font='12px Arial'; const w=ctx.measureText(text).width+pad*2, h=14+pad*2;
  ctx.fillStyle='#fff'; ctx.fillRect(x,y,w,h); ctx.strokeStyle='#ddd'; ctx.strokeRect(x,y,w,h); ctx.fillStyle='#000'; ctx.fillText(text,x+pad,y+pad+11);
}
function drawStartFinish(){ const s=worldToPx(S.start), f=worldToPx(S.finish); ctx.strokeStyle='#000'; ctx.lineWidth=1.5;
  ctx.beginPath(); ctx.moveTo(s.x-20,s.y); ctx.lineTo(s.x+20,s.y); ctx.stroke(); drawRectLabel(s.x-22,s.y-28,'START');
  ctx.beginPath(); ctx.moveTo(f.x-20,f.y); ctx.lineTo(f.x+20,f.y); ctx.stroke(); drawRectLabel(f.x-22,f.y-28,'FINISH');
}
function drawNumberCircle(num,cx,cy){ ctx.save(); ctx.beginPath(); ctx.arc(cx,cy,14,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#000'; ctx.stroke();
  ctx.fillStyle='#000'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(num,cx,cy); ctx.restore();
}
function drawJumpIcon(center,locked=false,angle=0,active=false){
  const p=worldToPx(center); const railW=32, railH=4, stdH=20, stdW=3, gap=railW/2;
  ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(angle+Math.PI/2); ctx.fillStyle='#000';
  ctx.fillRect(-gap-stdW,-stdH,stdW,stdH); ctx.fillRect(gap,-stdH,stdW,stdH); ctx.fillRect(-gap,-12,railW,railH);
  if(locked){ ctx.beginPath(); ctx.arc(0,-22,3,0,Math.PI*2); ctx.fill(); }
  if(active){ ctx.strokeStyle='#0b84ff'; ctx.setLineDash([2,2]); ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]); }
  ctx.restore(); drawNumberCircle(S.jumps.indexOf(center)+1,p.x,p.y-28);
}
function drawCurves(){ const {showLabels}=readUI(); ctx.lineWidth=LINE_WIDTH; ctx.setLineDash(DOT); ctx.strokeStyle='#333';
  for(const c of S.curves){ const a=worldToPx(c.a), b=worldToPx(c.b), m=worldToPx(c.c); ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.quadraticCurveTo(m.x,m.y,b.x,b.y); ctx.stroke();
    if(showLabels){ const t=0.5; const x=(1-t)*(1-t)*a.x+2*(1-t)*t*m.x+t*t*b.x; const y=(1-t)*(1-t)*a.y+2*(1-t)*t*m.y+t*t*b.y; drawRectLabel(x+6,y-6,`${c.strides} strides`); } }
  ctx.setLineDash([]);
}
function drawArrows(){ ctx.setLineDash([]); ctx.strokeStyle='#000'; ctx.lineWidth=ARROW_THICK;
  for(const c of S.arrows){ const a=c.a,b=c.b,m=c.c,t=0.85; const px=(1-t)*(1-t)*a.x+2*(1-t)*t*m.x+t*t*b.x; const py=(1-t)*(1-t)*a.y+2*(1-t)*t*m.y+t*t*b.y;
    const p=worldToPx({x:px,y:py}); const dx=2*(1-t)*(m.x-a.x)+2*t*(b.x-m.x); const dy=2*(1-t)*(m.y-a.y)+2*t*(b.y-m.y); const ang=Math.atan2(dy,dx), len=24, ex=p.x+Math.cos(ang)*len, ey=p.y+Math.sin(ang)*len;
    ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(ex,ey); ctx.stroke(); const a1=ang+Math.PI*0.85, a2=ang-Math.PI*0.85;
    ctx.beginPath(); ctx.moveTo(ex,ey); ctx.lineTo(ex+Math.cos(a1)*9,ey+Math.sin(a1)*9); ctx.moveTo(ex,ey); ctx.lineTo(ex+Math.cos(a2)*9,ey+Math.sin(a2)*9); ctx.stroke();
  }
}
function draw(){ ctx.clearRect(0,0,CV.width,CV.height); drawGrid(); drawArena(); drawCurves(); drawArrows(); drawStartFinish();
  for(let i=0;i<S.jumps.length;i++){ const j=S.jumps[i]; drawJumpIcon(j,j.locked,j.angle||0,i===S.selected); const cp=worldToPx(j); drawRectLabel(cp.x+20,cp.y-12,`${j.type} (${j.heightFt.toFixed(1)}ft)`); }
}

/* ===== Plan & status ===== */
function emitPlanAndStatus(){
  const u=S.units==='m'?'m':'ft', lvlKey=document.getElementById('level').value, lvl=LEVEL[lvlKey];
  let out=`Course Plan\nArena: ${Math.round(un(S.Wft,S.units))} x ${Math.round(un(S.Hft,S.units))} ${u}\nRule Set: ${document.getElementById('ruleSet').selectedOptions[0].text}\n\n`, tot=0;
  for(let i=0;i<S.jumps.length;i++){
    const j=S.jumps[i]; out+=`${i+1}. ${j.type} ~${j.heightFt.toFixed(1)}ft (x:${un(j.x,S.units).toFixed(1)} ${u}, y:${un(j.y,S.units).toFixed(1)} ${u})\n`;
    if(i>0){ const a=S.jumps[i-1], b=j; tot+=Math.hypot(b.x-a.x,b.y-a.y); const ln=S.lines[i-1]; out+=`   ‚Üí ${ln.strides} strides to ${i+1}\n`; }
  }
  if(S.jumps.length){ tot+=Math.hypot(S.jumps[0].x-S.start.x,S.jumps[0].y-S.start.y); tot+=Math.hypot(S.finish.x-S.jumps.at(-1).x,S.finish.y-S.jumps.at(-1).y); }
  const speed=lvl.speed, timeSec=Math.round((tot/speed)*60);
  planEl.textContent=out.trim(); statusEl.textContent=`Estimated length: ${S.units==='m'?(tot/FT_PER_M).toFixed(0)+' m':tot.toFixed(0)+' ft'} ‚Ä¢ Speed: ${speed} ft/min ‚Ä¢ Time Allowed ‚âà ${timeSec}s`;
}

/* ===== Interaction ===== */
CV.addEventListener('click',(e)=>{
  const rect=CV.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  for(let i=0;i<S.jumps.length;i++){
    const p=worldToPx(S.jumps[i]); const d2=(p.x-x)*(p.x-x)+(p.y-y)*(p.y-y);
    if(d2<22*22){
      if(e.shiftKey){ S.jumps[i].locked=!S.jumps[i].locked; renderAll(); drawThumb(); return; }
      S.selected=i; draw(); renderList(); drawThumb();
      const once=(ev)=>{
        CV.removeEventListener('click', once, true);
        const r=CV.getBoundingClientRect();
        let nx=(ev.clientX-r.left - S.origin.x)/S.scale, ny=(ev.clientY-r.top - S.origin.y)/S.scale;
        const minBuf=MIN_APPROACH_STRIDES*STRIDE; nx=clamp(nx,minBuf,S.Wft-minBuf); ny=clamp(ny,minBuf,S.Hft-minBuf);
        const snapped=snapPosition(i,nx,ny); S.jumps[i].x=snapped.x; S.jumps[i].y=snapped.y;
        if(i===0) S.jumps[0].angle=Math.atan2(S.jumps[0].y-S.start.y,S.jumps[0].x-S.start.x);
        else { const p=S.jumps[i-1]; S.jumps[i].angle=Math.atan2(S.jumps[i].y-p.y,S.jumps[i].x-p.x); }
        if(i+1<S.jumps.length){ const cur=S.jumps[i], nxt=S.jumps[i+1]; S.jumps[i+1].angle=Math.atan2(nxt.y-cur.y,nxt.x-cur.x); }
        computeCurves(); renderAll(); drawThumb();
      };
      CV.addEventListener('click', once, true); return;
    }
  }
  S.selected=-1; renderList(); draw(); drawThumb();
});

/* ===== Editor ===== */
function renderList(){
  listEl.innerHTML='';
  S.jumps.forEach((j,i)=>{
    const card=document.createElement('div'); card.className='item'+(i===S.selected?' active':''); card.onclick=()=>{ S.selected=i; draw(); renderList(); drawThumb(); };
    const title=document.createElement('div'); title.innerHTML=`<span class="badge">#${i+1}</span> ${j.type} ‚Ä¢ ${j.heightFt.toFixed(1)}ft`; card.appendChild(title);
    const grid=document.createElement('div'); grid.className='grid';
    const typeWrap=document.createElement('div'); typeWrap.innerHTML=`<label>Type</label>`; const typeSel=document.createElement('select');
    for(const t of TYPES){ const opt=document.createElement('option'); opt.value=t; opt.textContent=t; if(t===j.type) opt.selected=true; typeSel.appendChild(opt); }
    typeSel.onchange=()=>{ j.type=typeSel.value; computeCurves(); renderAll(); drawThumb(); }; typeWrap.appendChild(typeSel);
    const hWrap=document.createElement('div'); hWrap.innerHTML=`<label>Height (ft)</label>`; const hIn=document.createElement('input'); hIn.type='number'; hIn.step='0.1'; hIn.min='1.5'; hIn.max='5.0'; hIn.value=j.heightFt.toFixed(1);
    hIn.oninput=()=>{ const v=parseFloat(hIn.value||j.heightFt); j.heightFt=clamp(v,1.0,6.0); renderAll(); drawThumb(); }; hWrap.appendChild(hIn);
    const lockWrap=document.createElement('div'); lockWrap.innerHTML=`<label>Lock</label>`; const lockSel=document.createElement('select'); lockSel.innerHTML=`<option value="0">No</option><option value="1">Yes</option>`; lockSel.value=j.locked?'1':'0';
    lockSel.onchange=()=>{ j.locked=(lockSel.value==='1'); renderAll(); drawThumb(); }; lockWrap.appendChild(lockSel);
    const angWrap=document.createElement('div'); angWrap.innerHTML=`<label>Direction</label>`; const angDisp=document.createElement('input'); angDisp.type='text'; angDisp.disabled=true; angDisp.value=(j.angle*180/Math.PI).toFixed(0)+'¬∞'; angWrap.appendChild(angDisp);
    grid.appendChild(typeWrap); grid.appendChild(hWrap); grid.appendChild(lockWrap); grid.appendChild(angWrap); card.appendChild(grid);
    const xy=document.createElement('div'); xy.className='grid'; xy.style.marginTop='6px';
    const xw=document.createElement('div'); xw.innerHTML='<label>X</label>'; const xi=document.createElement('input'); xi.type='number'; xi.step='1'; xi.value=j.x.toFixed(0);
    xi.onchange=()=>{ const minBuf=MIN_APPROACH_STRIDES*STRIDE; let nx=clamp(parseFloat(xi.value||j.x),minBuf,S.Wft-minBuf); let ny=j.y; const s=snapPosition(i,nx,ny); j.x=s.x; j.y=s.y; updateAnglesAround(i); computeCurves(); renderAll(); drawThumb(); }; xw.appendChild(xi);
    const yw=document.createElement('div'); yw.innerHTML='<label>Y</label>'; const yi=document.createElement('input'); yi.type='number'; yi.step='1'; yi.value=j.y.toFixed(0);
    yi.onchange=()=>{ const minBuf=MIN_APPROACH_STRIDES*STRIDE; let ny=clamp(parseFloat(yi.value||j.y),minBuf,S.Hft-minBuf); let nx=j.x; const s=snapPosition(i,nx,ny); j.x=s.x; j.y=s.y; updateAnglesAround(i); computeCurves(); renderAll(); drawThumb(); }; yw.appendChild(yi);
    xy.appendChild(xw); xy.appendChild(yw); card.appendChild(xy);
    listEl.appendChild(card);
  });
}
function updateAnglesAround(i){
  if(i===0){ S.jumps[0].angle=Math.atan2(S.jumps[0].y-S.start.y,S.jumps[0].x-S.start.x); }
  else { const p=S.jumps[i-1]; S.jumps[i].angle=Math.atan2(S.jumps[i].y-p.y,S.jumps[i].x-p.x); }
  if(i+1<S.jumps.length){ const c=S.jumps[i], n=S.jumps[i+1]; S.jumps[i+1].angle=Math.atan2(n.y-c.y,n.x-c.x); }
}

/* ===== Thumb ===== */
function drawThumb(){
  tctx.clearRect(0,0,TH.width,TH.height); tctx.fillStyle='#fff'; tctx.fillRect(0,0,TH.width,TH.height); tctx.strokeStyle='#ddd'; tctx.strokeRect(0,0,TH.width,TH.height);
  if(S.selected<0||S.selected>=S.jumps.length){ tctx.fillStyle='#666'; tctx.font='12px Arial'; tctx.fillText('Select a jump to preview.',10,18); return; }
  const j=S.jumps[S.selected], prev=S.selected>0?S.jumps[S.selected-1]:S.start, next=S.selected<S.jumps.length-1?S.jumps[S.selected+1]:{x:j.x+relatedFt(5,j.type,'Vertical'),y:j.y};
  const scale=1.0; function map(pt){ return {x:TH.width/2+(pt.x-j.x)*scale, y:TH.height/2+(pt.y-j.y)*scale}; }
  function miniJump(x,y,angle,isCenter=false){ tctx.save(); const p=map({x,y}); tctx.translate(p.x,p.y); tctx.rotate((angle||0)+Math.PI/2); tctx.fillStyle='#000';
    const railW=26, railH=3, stdH=14, stdW=3, gap=railW/2; tctx.fillRect(-gap-stdW,-stdH,stdW,stdH); tctx.fillRect(gap,-stdH,stdW,stdH); tctx.fillRect(-gap,-9,railW,railH);
    if(isCenter){ tctx.strokeStyle='#0b84ff'; tctx.setLineDash([2,2]); tctx.beginPath(); tctx.arc(0,0,16,0,Math.PI*2); tctx.stroke(); tctx.setLineDash([]); } tctx.restore();
  }
  const dx1=j.x-prev.x, dy1=j.y-prev.y, d1=Math.hypot(dx1,dy1)||1; const mx1=(prev.x+j.x)/2, my1=(prev.y+j.y)/2, nx1=-dy1/d1, ny1=dx1/d1, curv1=0.12*d1; const c1={x:mx1+nx1*curv1,y:my1+ny1*curv1};
  const dx2=next.x-j.x, dy2=next.y-j.y, d2=Math.hypot(dx2,dy2)||1; const mx2=(j.x+next.x)/2, my2=(j.y+next.y)/2, nx2=-dy2/d2, ny2=dx2/d2, curv2=0.12*d2; const c2={x:mx2+nx2*curv2,y:my2+ny2*curv2};
  tctx.strokeStyle='#333'; tctx.setLineDash([8,8]); tctx.lineWidth=2;
  tctx.beginPath(); let p1=map(prev), m1=map(c1), j1=map(j); tctx.moveTo(p1.x,p1.y); tctx.quadraticCurveTo(m1.x,m1.y,j1.x,j1.y); tctx.stroke();
  tctx.beginPath(); let j2=map(j), m2=map(c2), n2=map(next); tctx.moveTo(j2.x,j2.y); tctx.quadraticCurveTo(m2.x,m2.y,n2.x,n2.y); tctx.stroke(); tctx.setLineDash([]);
  miniJump(prev.x,prev.y,Math.atan2(j.y-prev.y,j.x-prev.x),false); miniJump(j.x,j.y,j.angle||0,true); miniJump(next.x,next.y,Math.atan2(next.y-j.y,next.x-j.x),false);
}

/* ===== Export / Reset / Generate ===== */
document.getElementById('btnExportPNG').onclick=()=>{ const a=document.createElement('a'); a.download='barnpilot_course.png'; a.href=CV.toDataURL('image/png'); a.click(); };
document.getElementById('btnExportPDF').onclick=()=>{
  const img=CV.toDataURL('image/png'); const w=window.open('','_blank');
  const plan=planEl.textContent.replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\n/g,'<br>');
  w.document.write(`<html><head><title>BarnPilot Course PDF</title>
  <style>body{font-family:Arial,sans-serif;margin:24px;color:#111}img{max-width:100%;border:1px solid #ccc;border-radius:8px}
  pre{white-space:pre-wrap;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}</style></head><body>
  <h2>BarnPilot Course Designer</h2><img src="${img}" alt="Course Diagram"/><h3>Text Plan</h3><pre>${plan}</pre></body></html>`);
  w.document.close(); w.focus(); w.print();
};
document.getElementById('btnReset').onclick=()=>{ S.jumps=[]; S.lines=[]; S.curves=[]; S.arrows=[]; S.selected=-1; ctx.clearRect(0,0,CV.width,CV.height); planEl.textContent=''; statusEl.textContent=''; renderList(); drawThumb(); };
document.getElementById('btnGenerate').onclick=generate;

/* ===== List actions ===== */
document.getElementById('btnAddJump').onclick=()=>{
  const minBuf=MIN_APPROACH_STRIDES*STRIDE, x=clamp(rnd(minBuf,S.Wft-minBuf),minBuf,S.Wft-minBuf), y=clamp(rnd(minBuf,S.Hft-minBuf),minBuf,S.Hft-minBuf);
  const type=pick(TYPES), h=HEIGHT_BANDS[type][2], idx=S.selected>=0?S.selected+1:S.jumps.length;
  S.jumps.splice(idx,0,{x,y,type,heightFt:h,label:'',locked:false,angle:0,isComboPart:false});
  S.jumps.forEach((j,i)=> j.label=`Jump ${i+1}`); S.jumps.forEach((j,i)=>{ const p=(i===0)?S.start:S.jumps[i-1]; j.angle=Math.atan2(j.y-p.y,j.x-p.x); });
  computeCurves(); renderAll(); S.selected=idx; drawThumb();
};
document.getElementById('btnInsertCombo').onclick=()=>{
  if(S.selected<0 || S.selected>=S.jumps.length) return;
  const U=readUI(), RS=RULES[U.ruleSet].perLevel[U.lvlKey];
  const parts=(LEVEL[U.lvlKey].combo.two && Math.random()<0.5)?2:1, gap=comboGapFt(parts), minBuf=MIN_APPROACH_STRIDES*STRIDE;
  const base=S.jumps[S.selected], dir=(base.x<S.Wft/2)?1:-1, nx=clamp(base.x+dir*gap,minBuf,S.Wft-minBuf), ny=clamp(base.y,minBuf,S.Hft-minBuf);
  let typeB = (parts===2 && gap<RS.oxerBOrCAfterMinTwoStrideFt) ? 'Vertical' : (Math.random()<0.5?'Vertical':'Oxer');
  S.jumps.splice(S.selected+1,0,{x:nx,y:ny,type:typeB,heightFt:base.heightFt,label:'',locked:false,angle:0,isComboPart:true});
  S.jumps.forEach((j,i)=> j.label=`Jump ${i+1}`); S.jumps.forEach((j,i)=>{ const p=(i===0)?S.start:S.jumps[i-1]; j.angle=Math.atan2(j.y-p.y,j.x-p.x); });
  computeCurves(); renderAll(); drawThumb();
};
document.getElementById('btnDeleteJump').onclick=()=>{
  if(S.selected<0) return;
  S.jumps.splice(S.selected,1); S.jumps.forEach((j,i)=> j.label=`Jump ${i+1}`);
  S.jumps.forEach((j,i)=>{ const p=(i===0)?S.start:S.jumps[i-1]; j.angle=Math.atan2(j.y-p.y,j.x-p.x); });
  S.selected=Math.min(S.selected,S.jumps.length-1); computeCurves(); renderAll(); drawThumb();
};
document.getElementById('btnMoveUp').onclick=()=>{
  if(S.selected<=0) return; const i=S.selected; const tmp=S.jumps[i-1]; S.jumps[i-1]=S.jumps[i]; S.jumps[i]=tmp;
  S.jumps.forEach((j,k)=> j.label=`Jump ${k+1}`); S.jumps.forEach((j,k)=>{ const p=(k===0)?S.start:S.jumps[k-1]; j.angle=Math.atan2(j.y-p.y,j.x-p.x); });
  S.selected=i-1; computeCurves(); renderAll(); drawThumb();
};
document.getElementById('btnMoveDown').onclick=()=>{
  if(S.selected<0 || S.selected>=S.jumps.length-1) return; const i=S.selected; const tmp=S.jumps[i+1]; S.jumps[i+1]=S.jumps[i]; S.jumps[i]=tmp;
  S.jumps.forEach((j,k)=> j.label=`Jump ${k+1}`); S.jumps.forEach((j,k)=>{ const p=(k===0)?S.start:S.jumps[k-1]; j.angle=Math.atan2(j.y-p.y,j.x-p.x); });
  S.selected=i+1; computeCurves(); renderAll(); drawThumb();
};

/* ===== Render all & init ===== */
function renderAll(){ draw(); emitPlanAndStatus(); renderList(); }
generate();
</script>
</body>
</html>